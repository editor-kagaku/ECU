diff -uNr ecu_education_work_initial/swc-application/1ecu/ecu_cbo/Makefile ecu_education_work_step0/swc-application/1ecu/ecu_cbo/Makefile
--- ecu_education_work_initial/swc-application/1ecu/ecu_cbo/Makefile	2023-06-06 03:12:40.112664800 +0900
+++ ecu_education_work_step0/swc-application/1ecu/ecu_cbo/Makefile	2023-07-04 04:24:28.888474100 +0900
@@ -191,7 +191,7 @@
 ifndef OMIT_OPTIMIZATION
   COPTS := $(COPTS) -O2
 endif
-USER_MACRO = -DTOPPERS_NO_USE_SCHM -DTOPPERS_NO_USE_COMSTACK -DTOPPERS_USE_BODY -DTOPPERS_USE_OPERATION -DTOPPERS_USE_CONTROL
+USER_MACRO = -DTOPPERS_NO_USE_SCHM -DTOPPERS_NO_USE_COMSTACK -DTOPPERS_USE_BODY -DTOPPERS_USE_OPERATION -DTOPPERS_USE_CONTROL -DSIMULATE_ON_ATHRILL
 CDEFS := $(CDEFS)  $(USER_MACRO)
 INCLUDES := -I. -I$(SRCDIR)/include -I$(SRCDIR)/arch -I$(SRCDIR) $(INCLUDES)
 LDFLAGS := $(LDFLAGS) 
diff -uNr ecu_education_work_initial/swc-application/1ecu/ecu_cbo/device_config.txt ecu_education_work_step0/swc-application/1ecu/ecu_cbo/device_config.txt
--- ecu_education_work_initial/swc-application/1ecu/ecu_cbo/device_config.txt	2023-06-06 03:12:40.136663100 +0900
+++ ecu_education_work_step0/swc-application/1ecu/ecu_cbo/device_config.txt	2023-07-04 05:09:06.425864300 +0900
@@ -3,4 +3,4 @@
 DEBUG_FUNC_ENABLE_BT		1
 DEBUG_FUNC_ENABLE_PROF		1
 DEBUG_FUNC_ENABLE_WATCH		1
-DEBUG_FUNC_ENABLE_SKIP_CLOCK    1
+DEBUG_FUNC_ENABLE_SKIP_CLOCK    0
diff -uNr ecu_education_work_initial/swc-application/1ecu/ecu_cbo/device_config_with_can.txt ecu_education_work_step0/swc-application/1ecu/ecu_cbo/device_config_with_can.txt
--- ecu_education_work_initial/swc-application/1ecu/ecu_cbo/device_config_with_can.txt	2023-06-06 03:12:40.139663100 +0900
+++ ecu_education_work_step0/swc-application/1ecu/ecu_cbo/device_config_with_can.txt	2023-07-04 05:08:56.976744000 +0900
@@ -3,7 +3,7 @@
 DEBUG_FUNC_ENABLE_BT		1
 DEBUG_FUNC_ENABLE_PROF		1
 DEBUG_FUNC_ENABLE_WATCH		1
-DEBUG_FUNC_ENABLE_SKIP_CLOCK    1
+DEBUG_FUNC_ENABLE_SKIP_CLOCK    0
 DEBUG_FUNC_ENABLE_CAN      1
 DEVICE_CONFIG_CAN_FD		100000
 DEBUG_FUNC_CAN_RX_QUEUE_SIZE	256
diff -uNr ecu_education_work_initial/swc-application/1ecu/ecu_cbo/memory.txt ecu_education_work_step0/swc-application/1ecu/ecu_cbo/memory.txt
--- ecu_education_work_initial/swc-application/1ecu/ecu_cbo/memory.txt	2023-06-06 03:12:40.150683700 +0900
+++ ecu_education_work_step0/swc-application/1ecu/ecu_cbo/memory.txt	2023-06-06 03:13:42.229902400 +0900
@@ -4,3 +4,4 @@
 MMAP, 0xFFCE5000, mmap2.bin
 MMAP, 0xFFCF0000, mmap3.bin
 MMAP, 0xFFE30000, mmap4.bin
+MMAP, 0xFF305288, mmap5.bin
\ No newline at end of file
diff -uNr ecu_education_work_initial/swc-application/EcuM/EcuM_Callout.h ecu_education_work_step0/swc-application/EcuM/EcuM_Callout.h
--- ecu_education_work_initial/swc-application/EcuM/EcuM_Callout.h	2023-06-06 03:12:40.499240600 +0900
+++ ecu_education_work_step0/swc-application/EcuM/EcuM_Callout.h	2023-06-06 03:13:42.568621400 +0900
@@ -73,10 +73,10 @@
 	print_banner();
 }
 
-#define ALARM_TICK_125US	1000U
-#define ALARM_TICK_10MS		80000U
-#define ALARM_TICK_20MS		160000U
-#define ALARM_TICK_100MS	800000U
+#define ALARM_TICK_125US	200000U
+#define ALARM_TICK_10MS		20000U
+#define ALARM_TICK_20MS		40000U
+#define ALARM_TICK_100MS	200000U
 
 LOCAL_INLINE void
 EcuM_BswStartupTwo(void)
diff -uNr ecu_education_work_initial/swc-application/common/swcs/CddController.c ecu_education_work_step0/swc-application/common/swcs/CddController.c
--- ecu_education_work_initial/swc-application/common/swcs/CddController.c	2023-06-06 03:12:40.549148000 +0900
+++ ecu_education_work_step0/swc-application/common/swcs/CddController.c	2023-06-06 03:13:42.617034500 +0900
@@ -131,6 +131,24 @@
 {
 	uint8 c;
 
+#if SIMULATE_ON_ATHRILL
+	g_rcb3_rmsg[0] = (*(uint8*)(0xFF305288));
+	g_rcb3_rmsg[1] = (*(uint8*)(0xFF305289));
+	g_rcb3_rmsg[2] = (*(uint8*)(0xFF30528A));
+	g_rcb3_rmsg[3] = (*(uint8*)(0xFF30528B));
+	g_rcb3_rmsg[4] = (*(uint8*)(0xFF30528C));
+	g_rcb3_rmsg[5] = (*(uint8*)(0xFF30528D));
+	g_rcb3_rmsg[6] = (*(uint8*)(0xFF30528E));
+	g_rcb3_rmsg[7] = (*(uint8*)(0xFF30528F));
+
+	RCB3CommandData = (IDT_RCB3) g_rcb3_rmsg[RCB3_MSG_OFFSET_BUTTON_L];         /* ボタン情報1 */
+	RCB3CommandData += ((IDT_RCB3) g_rcb3_rmsg[RCB3_MSG_OFFSET_BUTTON_H]) << 8U;/* ボタン情報2 */
+	RCB3CommandData += ((IDT_RCB3) g_rcb3_rmsg[RCB3_MSG_OFFSET_L_ANALOG_LR]) << 16U;  /* アナログ1 */
+	RCB3CommandData += ((IDT_RCB3) g_rcb3_rmsg[RCB3_MSG_OFFSET_R_ANALOG_UD]) << 24U;  /* アナログ4 */
+	/*syslog_1(LOG_NOTICE, "MessageParser:%08x", RCB3CommandData);*/
+	RCB3CommandGotFlg = FALSE;
+	rx_mode = RX_MODE_INIT;
+#else
 	while (tReceiveSBDBTUart(&c, 1)) {
 		switch (rx_mode) {
 		case RX_MODE_INIT:
@@ -175,6 +193,7 @@
 #endif /* TOPPERS_WITH_DISP */
 		}
 	}
+#endif
 }
 
 /*
diff -uNr ecu_education_work_initial/swc-application/common/swcs/CddLedBlinker.c ecu_education_work_step0/swc-application/common/swcs/CddLedBlinker.c
--- ecu_education_work_initial/swc-application/common/swcs/CddLedBlinker.c	2023-06-06 03:12:40.560691700 +0900
+++ ecu_education_work_step0/swc-application/common/swcs/CddLedBlinker.c	2023-06-06 03:57:22.069416400 +0900
@@ -46,6 +46,7 @@
 
 #include "Rte_CddLedBlinker.h"
 #include "ModelCarControl.h"
+#include "t_syslog.h"
 
 /*
  *  CDD SW-C CddLedBlinker用の初期化
@@ -53,6 +54,8 @@
 void
 CddLedBlinkerInit(void)
 {
+	switch_dip_init();
+	switch_push_init();
 	led_init();
 }
 
@@ -65,19 +68,50 @@
 	static uint8	active_led_val = LED1;
 	static boolean	active_led_up  = TRUE;
 
-	led_out(active_led_val);
-
-	if(active_led_val == LED4){
-		active_led_up = FALSE;
-	}
-	if(active_led_val == LED1){
-		active_led_up = TRUE;
+	static IDT_Switch dsw_state = 0;
+	static IDT_Switch latch = 0; 
+	IDT_Switch	psw_state = 0;
+	Std_ReturnType ret = 0;
+
+	if ( latch == 0 )
+	{
+		/* DSW の値は一度だけ取得するため、ラッチでそれを保証する	*/
+#if SIMULATE_ON_ATHRILL
+		/* シミュレーションでは、DSW初期化で値がクリアされるため、	*/
+		/* メモリファイルを次の瞬間に戻す仕組みが必要となる			*/
+		/* ただし、仕組みが手間なので、ひとまずメモリ読出しで対応	*/
+		dsw_state = (IDT_Switch)(*(uint8*)(0xFF305290));
+#else
+		dsw_state = (IDT_Switch)switch_dip_sense();
+#endif
+		syslog_1(LOG_NOTICE, "LedBlinker:dsw:%02x", dsw_state );
+		latch = 1;
 	}
 
-	if(active_led_up == TRUE){
-		active_led_val = active_led_val << 1;
+	psw_state = (IDT_Switch)switch_push_sense();
+
+	syslog_2(LOG_NOTICE, "LedBlinker:dsw psw:%02x %02x", dsw_state, psw_state );
+	if ( dsw_state == 0 && psw_state == 0 ) {	/* dsw がすべて off かつ psw が off */
+		led_out(active_led_val);
+
+		if(active_led_val == LED4){
+			active_led_up = FALSE;
+		}
+		if(active_led_val == LED1){
+			active_led_up = TRUE;
+		}
+
+		if(active_led_up == TRUE){
+			active_led_val = active_led_val << 1;
+		}
+		else {
+			active_led_val = active_led_val >> 1;
+		}
 	}
 	else {
-		active_led_val = active_led_val >> 1;
+		led_out(0);
 	}
+#if SIMULATE_ON_ATHRILL
+	syslog_1(LOG_NOTICE, "LedBlinker:State:%02x", (*(uint8*)(0xffc10020)));
+#endif
 }
